<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Shuto" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="3S, ゲノム配列解析論Ⅱ, ゲノム配列解析論Ⅱ, " />
<meta property="og:image" content="https://iwasakishuto.github.io/lecture/notes/theme/img/default_image.png"/>

<meta property="og:title" content="ゲノム配列解析論Ⅱ 第3回 "/>
<meta property="og:url" content="https://iwasakishuto.github.io/study/notes/ゲノム配列解析論Ⅱ-3.html" />
<meta property="og:description" content="RNA informatics" />
<meta property="og:site_name" content="My Notes" />
<meta property="og:article:author" content="Shuto" />
<meta property="og:article:published_time" content="2019-06-24T00:00:00+09:00" />
<meta property="og:article:modified_time" content="2019-06-24T00:00:00+09:00" />
<meta name="twitter:title" content="ゲノム配列解析論Ⅱ 第3回 ">
<meta name="twitter:description" content="RNA informatics">

        <title>ゲノム配列解析論Ⅱ 第3回  · My Notes
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://iwasakishuto.github.io/study/notes/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://iwasakishuto.github.io/study/notes/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://iwasakishuto.github.io/study/notes/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://iwasakishuto.github.io/study/notes/theme/css/admonition.css" media="screen">



        <!-- Syntax highlight -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <!-- LaTex -->
        <!-- Github env -->
        <!--<script type="text/javascript" async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
        <script type="text/x-mathjax-config">
        	MathJax.Hub.Config({
        		tex2jax: {
        			inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        			displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        		}
        	});
        </script>
        <!-- Mermaid -->
        <script src="https://unpkg.com/mermaid/dist/mermaid.min.js" charset="UTF-8"></script>
        <script>
          mermaid.initialize({
            startOnLoad:true
          });
        </script>
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://iwasakishuto.github.io/study/notes/"><span class=site-name>My Notes</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://iwasakishuto.github.io/study/notes">Home</a></li>
                            <li ><a href="https://iwasakishuto.github.io/study/notes/categories">Categories</a></li>
                            <li ><a href="https://iwasakishuto.github.io/study/notes/tags">Tags</a></li>
                            <li ><a href="https://iwasakishuto.github.io/study/notes/archives">Archives</a></li>
                            <li><form class="navbar-search" action="https://iwasakishuto.github.io/study/notes/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="https://iwasakishuto.github.io/study/notes/ゲノム配列解析論Ⅱ-3.html"> ゲノム配列解析論Ⅱ 第3回  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            
            <h1>第3回 2019/6/24</h1>
<ul>
<li>講師：<a href="https://www.u-tokyo.ac.jp/focus/ja/people/k0001_01900.html">寺井 悟郎</a></li>
</ul>
<h2>Table of contents</h2>
<ol>
<li><a data-scroll href="#anchor1">RNA secondary structure</a></li>
<li><a data-scroll href="#anchor2">Nussinov algorithm</a></li>
<li><a data-scroll href="#anchor3">Zuker algorithm</a></li>
<li><a data-scroll href="#anchor4">McCaskill algorithm</a></li>
</ol>
<h2 id="anchor1">1. RNA secondary structure</h2>

<p>遺伝子の実態はタンパク質であり、RNAはDNAとタンパク質の橋渡しをしているだけだと考えられていたが、ncRNAなど、RNA単独でも様々、かつ重要な機能を果たすことがわかってきた。</p>
<p>例えば、ncRNAのうち長さが21~23塩基程度のmiRNAは、まず<font color="red"><b>ヘアピン構造</b></font>を持つ長いRNA<font color="red"><b>(pri-miRNA)</b></font>として転写される。</p>
<p>その後、ヘアピン構造の基部を切断するRNA分解酵素<font color="red"><b>Drosha</b></font>により、中間産物のpre-miRNAが切り出される。pri-miRNAはさらに<font color="red"><b>Dicer</b></font>によって切断されて二本鎖のmiRNAとなった後、その片方、もしくは両方が<font color="red"><b>mature miRNA</b></font>として機能する。</p>
<p>このように、miRNAが正しいプロセシングを受けるためには、特徴的な構造が不可欠である。</p>
<p>また、mRNAの結合部位にヘアピン構造などの二次構造があるとRISCが近づけず、RNAiが起こらないことも知られている。</p>
<p>これらの機能を理解するためにも、RNAの構造予測や構造比較が重要になっている。</p>
<p>しかし、RNAの3次元構造決定はタンパク質よりも困難な場合が多く、既知のデータも少ないので、現在の研究の中心は、<font color="red"><b>どの塩基とどの塩基が立体構造中で結合しているか</b></font>を表現した<b>二次構造</b>と呼ばれる<b>一種のグラフ構造の予測や比較</b>である。</p>
<h3>擬似ノット(pseidoknot)</h3>
<p>これ以降3つの2次構造予測アルゴリズムを紹介するが、それらはどれも<font color="red"><b>擬似ノット(pseidoknot)</b></font>なしの2次構造のみを対象とすることに注意が必要である。</p>
<p>擬似ノットを含む2次構造の予測については<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5886407/">この論文</a>が詳しそう。</p>
<h4>定義</h4>
<p>以下のいずれかを満たす2個の塩基対 <span class="math">\((i,j),(i',j')\in A\)</span> は擬似ノットと呼ばれる。
- <span class="math">\(i&lt;i'&lt;j&lt;j'\)</span>
- <span class="math">\(i'&lt;i&lt;j'&lt;j\)</span></p>
<p><img src="https://image3.slideserve.com/5673863/slide27-l.jpg"></p>
<p><b>擬似ノットがある場合、少なくとも1つの対は交差することになる。</b></p>
<h2 id="anchor2">2. Nussinov algorithm</h2>

<p>RNA二次構造予測問題は<b>「考えられる様々な2次構造から生物学的にもっとも正しい構造を選ぶ問題」</b>であり、一般に<font color="red"><b>エネルギー最小化問題</b></font>として定義される。<b>（細胞内では、RNAはエネルギー的に安定な構造をとると考えられるから。）</b></p>
<p><font color="red"><b>Nussinov algorithm</b></font>もその一つであり、<font color="red"><b>「結合する塩基対はどれも同じ程度の負のエネルギーを持つ」</b></font>という最も簡単な仮定をおく。（つまり、<b>塩基対が多ければ多いほど生物学的に正しいであろう</b>という仮定）</p>
<h3>The basic idea</h3>
<p>より短い部分配列の最適構造を伸ばしたり組み合わせることで目的の配列の最適構造を求める。以下の変数を定義する。</p>
<p>ここでDP matrixを用意するが、このDP matrixの斜めの線は、<b>長さ <span class="math">\(n\)</span> の部分配列の最大塩基対数</b>を表している。</p>
<div class="math">$$
\begin{aligned}
\delta(i,j)
&amp;=\left
  \{\begin{array}{ll}
  {1}
  &amp; {\text { if i and j-th nucleotides can form a base-pair}}\\
  {0}
  &amp; {\text { otherwise }}
  \end{array}
\right.\\
\gamma(i,j)
&amp;= \text{Maximum number of base pairs of partial sequence from i to j}
\end{aligned}$$</div>
<h3>Algorithm</h3>
<p>アルゴリズムは、以下のようにかける。</p>
<ul>
<li>Initialization:
<div class="math">$$
\begin{array}{l}{\gamma(i, i)=0 \text { for } i=1 \text { to } L} \\ {\gamma(i, i-1)=0 \text { for } i=2 \text { to } L}\end{array}
$$</div>
</li>
<li>Recursion:
<div class="math">$$
\gamma(i, j)=\max
\left\{\begin{array}{c}
{\gamma(i+1, j)} \\
{\gamma(i, j-1)} \\
{\gamma(i+1, j-1)+\delta(i, j)} \\
{\max _{i \leq k&lt;j}[\gamma(i, k)+\gamma(k+1, j)]}
\end{array}\right.
$$</div>
</li>
</ul>
<p><img src="https://bibiserv.cebitec.uni-bielefeld.de/sadr2/rnasecondarystructure/secondarystructureprediction/Nussinov.jpg"></p>
<p>この計算では、一つの要素を決めるのに <span class="math">\(O(L)\)</span> の計算量がかかり、それが <span class="math">\(O(L^2)\)</span> あるので、計算量は <span class="math">\(O(L^3)\)</span> である。一方メモリは要素数に比例するので、<span class="math">\(O(L^2)\)</span> である。</p>
<h3>Bifurcation</h3>
<p>上の再帰式の最後の行は <font color="red"><b>Bifurcation</b></font>と呼ばれ、<b>「ある部分配列とある部分配列の最大塩基対数の和が全体配列の最大塩基対数になる時」</b>に非常に重要な役割を果たす。</p>
<h3>Traceback</h3>
<p>トレースバックが複数ある場合は、最適構造が複数あることを意味している。以下のトレースバックアルゴリズムでは、そのうち一つのみを求めることができる。</p>
<div class="highlight"><pre><span></span><span class="c1">#=== Initialization ===</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">record</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="p">))</span>
<span class="c1">#=== Recursion ===</span>
<span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">):</span> <span class="k">continue</span>
  <span class="k">elif</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
  <span class="k">elif</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">elif</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="err">δ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="n">record</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
      <span class="k">if</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="err">γ</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="err">γ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">break</span>
</pre></div>


<h2 id="anchor3">3. Zuker algorithm</h2>

<p><font color="red"><b>Zuker algorithm</b></font>では、Nussinov algorithmの時より複雑にエネルギーを計算することになる。</p>
<p>二次構造のエネルギーは、<font color="red"><b>ループ(loop)</b></font>と呼ばれる部分構造（塩基対で閉じられた構造）の自由エネルギーの和として近似される。</p>
<p><img src="https://www.researchgate.net/profile/Adane_Mamuye/publication/311394313/figure/fig1/AS:436664821653510@1481120415005/An-RNA-secondary-structure-with-examples-of-the-five-kinds-of-loops-hairpin-blue.png"></p>
<p>例えば上の図形だと、以下のような様々なループが存在し、それぞれのエネルギーの総和で全体のエネルギーが表されるとする。</p>
<ul>
<li><font color="blue"><b>青色のhairpin構造</b></font>は一つの塩基対で閉じられたループ</li>
<li><font color="yellow"><b>黄色のbulge構造</b></font>は二つの塩基対によって閉じられたループ</li>
<li><font color="cyan"><b>シアンのmulti-branched構造</b></font>は三つの塩基対によって閉じられたループ</li>
</ul>
<p>ここで、それぞれのループの自由エネルギーを以下のように定義する。</p>
<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">例</th>
<th align="left">式</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1つの塩基対で作られたループ</td>
<td align="left">hairpin loop</td>
<td align="left"><span class="math">\(F_1(i,j)\)</span></td>
</tr>
<tr>
<td align="left">2つの塩基対で作られたループ</td>
<td align="left">stacking,bulge loop, internal loop</td>
<td align="left"><span class="math">\(F_2(i,j,h,l)\)</span></td>
</tr>
<tr>
<td align="left">3つ以上の塩基対で閉じられたループ</td>
<td align="left">multi-loop</td>
<td align="left"><span class="math">\(F_m=a+bk+cu\)</span></td>
</tr>
</tbody>
</table>
<p>ここで、<span class="math">\(k\)</span> は塩基対を形成している塩基対の数で、<span class="math">\(u\)</span> は塩基対を形成していない塩基の数である。<span class="math">\(a,b,c\)</span> は定数であり、またそれ以外の <span class="math">\(F_1,F_2\)</span> という関数も予め実験的に求まっているものとする。（ex. <span class="math">\(F_1(C-G) = -3.4 \mathrm{kcal/mol},F_1(A-U) = -0.9 \mathrm{kcal/mol}\)</span>）</p>
<h3>Algorithm</h3>
<p>Zuker algorithm は基本的には<b>Nussinov algorithm</b>と似ているが、以下の<font color="red"><b>2つのDP matrix</b></font>を持つ。</p>
<ul>
<li><span class="math">\(i,j\)</span> が塩基対を組まない場合のDP matrix <span class="math">\(W(i,j)\)</span></li>
<li><span class="math">\(i,j\)</span> が塩基対を組む場合のDP matrix <span class="math">\(V(i,j)\)</span></li>
</ul>
<h4><span class="math">\(W(i,j)\)</span></h4>
<p><span class="math">\(W(i,j)\)</span> は以下の式によって求めることができる。</p>
<div class="math">$$
W(i, j)=\min
\left\{\begin{array}{c}
{W(i-1, j)} \\
{W(i, j+1)} \\
{V(i, j)} \\
{\min _{i \leq k&lt;j}\{W(i, k)+W(k+1, j)\}}
\end{array}\right.
$$</div>
<h4><span class="math">\(V(i,j)\)</span></h4>
<p>続いて <span class="math">\(V(i,j)\)</span> の計算についてだが、<span class="math">\((i,j)\)</span> 塩基対がどの構造を作るかによって場合分けが必要であり、以下のようになる。</p>
<div class="math">$$
V(i, j)=\min
\left\{\begin{array}{c}
{F_{1}(i, j)} \\
{\min _{i&lt;h&lt;l&lt;j} F_{2}(i, j, h, l)+V(h, l)} \\
{\min _{i+1&lt;k&lt;j-1}\{(W(i+1, k)+W(k+1, j-1)\}}
\end{array}\right.
$$</div>
<p>※なお、<font color="red"><b>ここでは <span class="math">\(F_m=0\)</span> と仮定し、考慮していない</b></font><span class="math">\(F_m\)</span> を考慮するためには、さらに2個のDP matrixを考える必要があり、複雑になってしまうためである。（ソフトウェア（<a href="http://rna.tbi.univie.ac.at/cgi-bin/RNAWebSuite/RNAfold.cgi">RNAfold</a>など）では考慮されている。）</p>
<h3>Traceback</h3>
<p>Nussinov algorithmのトレースバックと似ているが、<b>どちらの行列をたどっているかを記憶する変数</b>が必要であり、さらに行列 <span class="math">\(V\)</span> のトレースバックを新たに考える必要がある。</p>
<div class="highlight"><pre><span></span><span class="c1">#=== Initialization ===</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">record</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">))</span>
<span class="c1">#=== Recursion ===</span>
<span class="k">while</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
  <span class="k">elif</span><span class="p">(</span><span class="n">m</span><span class="o">==</span><span class="s2">&quot;w&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s2">&quot;v&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">W</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
          <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
          <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
          <span class="k">break</span>
  <span class="k">elif</span><span class="p">(</span><span class="n">m</span><span class="o">==</span><span class="s2">&quot;v&quot;</span><span class="p">):</span>
    <span class="c1"># hairpin loop</span>
    <span class="k">if</span> <span class="n">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">F_1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span> <span class="n">record</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">F_2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">V</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
            <span class="n">record</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="c1"># w??</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">break</span>
      <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>      
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">W</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">W</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">satck</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="k">break</span>
</pre></div>


<p>ここまで、与えられた配列の<b>二次構造を予測</b>してきた。</p>
<h2 id="anchor4">4. McCaskill Algorithm</h2>

<p>ここからは、与えられた配列の<b>塩基対確率行列を計算する</b>方法を学ぶ。</p>
<p>ex.) "GGGAAAUCC" という配列を考える。すると、以下の <span class="math">\(20\)</span> 通りの配列を取り得る。<b>（<font color="red">ワトソンクリック対</font>と<font color="red">Wobble対</font>のみが対合できるという条件下で）</b></p>
<p>まず、簡単のためにそれぞれの配列になる確率が等確率であるとする。</p>
<table>
<thead>
<tr>
<th align="center">GGGAAAUCC</th>
<th align="center">Probability</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">.........</td>
<td align="center">1/20</td>
</tr>
<tr>
<td align="center"><font color="red">(((...)))</font></td>
<td align="center">1/20</td>
</tr>
<tr>
<td align="center"><font color="red">((.....))</font></td>
<td align="center">1/20</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">:</td>
</tr>
<tr>
<td align="center"><font color="red">.((...)).</font></td>
<td align="center">1/20</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">:</td>
</tr>
<tr>
<td align="center"><font color="red">.(.....).</font></td>
<td align="center">1/20</td>
</tr>
<tr>
<td align="center">:</td>
<td align="center">:</td>
</tr>
<tr>
<td align="center">..(...)..</td>
<td align="center">1/20</td>
</tr>
</tbody>
</table>
<p>ここで、2番目の"G"と8番目の"C"が対合する配列は上の赤で示した4通りである。したがって、<strong>「2番目の"G"と8番目の"C"が対合する確率は <span class="math">\(4/20\)</span> 」</strong> と結論付けることができる。</p>
<p>もちろんこの仮定は<b>あまりにも単純すぎ</b>であり、本来は異なるエネルギーを持つ構造のうち、安定なものを取りやすいはずである。</p>
<p>したがって、それぞれの構造ごとにエネルギー <span class="math">\(E(\sigma_i)\)</span> を割り当て、それに従って <span class="math">\(P(\sigma_i)\)</span> が計算される、とするべきである。</p>
<h3>Boltzmann distribution</h3>
<p><span class="math">\(E(\sigma_i)\)</span> から <span class="math">\(E(\sigma_i)\)</span> を計算する式が必要になるが、RNAの二次構造の確率は、<font color="red"><b>ボルツマン分布(Boltzmann distribution)に従う</b></font>と仮定する。</p>
<div class="math">$$\mathrm{P}(\sigma) \propto e^{-E(\sigma) / k T}$$</div>
<p>この時、上の式の変数はそれぞれ以下の意味を持つ。</p>
<ul>
<li><span class="math">\(e^{-E(\sigma) / k T}\)</span> をボルツマン因子(Boltzmann factor)</li>
<li><span class="math">\(k\)</span> を定数</li>
<li><span class="math">\(T\)</span> を温度(Temperature)</li>
</ul>
<p>※エネルギーがボルツマン分布に従うという仮定は物理の世界ではかなり一般的な概念であり、<b>粒子の集合が合計で <span class="math">\(Z\)</span> のエネルギーを持つ時に、個々の粒子にエネルギーが等確率で分配されるというモデルを考えるとわかる。</b></p>
<p>従って、エネルギーから確率への変換は、以下のように表すことができる。</p>
<div class="math">$$
\begin{array}{l}{\mathrm{P}(\sigma)=\frac{e^{-E(\sigma) / k T}}{Z}} \\ {Z=\sum_{\sigma^{\prime}} e^{-E\left(\sigma^{\prime}\right) / k T}}\end{array}
$$</div>
<h3>DP matrix</h3>
<p>短い配列の場合は先ほどの表のように全ての取り得る配列を列挙することができるが、配列が長くなるとかなり厳しい。</p>
<p>そこで、これを<font color="red"><b>McCaskill algorithm</b></font>で今まで同様に動的計画法によって求める。</p>
<p>なお、McCaskill Algorithm の計算量は <span class="math">\(O(L^3)\)</span> で、メモリは <span class="math">\(O(L^2)\)</span> 必要で、Nacinohu Algorithm や Zuker Algorithm と等しい。</p>
<h3>注意点</h3>
<h4>値の丸め込み</h4>
<p>McCaskill Algorithm では、<font color="red"><b>「ある2次構造のエネルギーはその部分構造のエネルギーの和として求めることができる。」</b></font>とするが、この時以下のように<font color="red"><b>掛け算</b></font>が出てくる。</p>
<div class="math">$$
\begin{aligned}
E(\sigma)
&amp;=E\left(\sigma^{L}\right)+E\left(\sigma^{R}\right)\\
e^{-E(\sigma) / k T}
&amp;=e^{-\left[E\left(\sigma^{L}\right)+E\left(\sigma^{R}\right)\right] / k T} \\
&amp;=e^{-E\left(\sigma^{L}\right) / k T} \cdot e^{-E\left(\sigma^{R}\right) / k T}
\end{aligned}
$$</div>
<p>すると、DP行列に入る値が非常に大きく or 小さくなってしまう。そこで、<font color="red"><b>ログを取る</b></font>もしくは<font color="red"><b>スケーリングする</b></font>必要が出てくる。</p>
<h4>2次構造のダブルカウント</h4>
<p><font color="red"><b>分配関数 <span class="math">\(Z\)</span> </b></font>は、「全ての取り得る2次構造のボルツマン因子の和」として定義されていた。従って、同じ2次構造のボルツマン因子を二度足し合わせることはできない。</p>
<p>部分構造のボルツマン因子から全体構造のボルツマン因子を計算する際には、<font color="red"><b>「異なる部分構造の分け方が同じ二次構造のボルツマン因子になり得る」</b></font>ということに注意が必要である。</p>
<p>Nacinohu Algorithm や Zuker Algorithm では <span class="math">\(\mathrm{Max}\)</span> や <span class="math">\(\mathrm{Min}\)</span> を取っていたためこのような<font color="red"><b>ダブルカウント</b></font>は問題にならなかったが、今回のアルゴリズムでは注意しなくてはならない。</p>
<h3>Algorithm</h3>
<p>McCaskill algorithm では、5つのDP matrixを考えることになる。</p>
<h3>各変数の役割</h3>
<table>
<thead>
<tr>
<th align="center">変数</th>
<th align="left">役割</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><span class="math">\(Z_{ij}\)</span></td>
<td align="left">部分配列 <span class="math">\(i\)</span> から <span class="math">\(j\)</span> までの全ての可能な2次構造のボルツマン因子の和。（つまり、<span class="math">\(i\)</span> から <span class="math">\(j\)</span> までの部分配列の分配関数）Zuker Algorithm の <span class="math">\(W(i,j)\)</span> に対応。</td>
</tr>
<tr>
<td align="center"><span class="math">\(Z_{ij}^1\)</span></td>
<td align="left">2次構造のダブルカウントを防ぐ。</td>
</tr>
<tr>
<td align="center"><span class="math">\(Z_{ij}^b\)</span></td>
<td align="left"><span class="math">\(i\)</span> と <span class="math">\(j\)</span> が塩基対を組む時の全ての可能な2次構造のボルツマン因子の和。Zuker Algorithm の <span class="math">\(V(i,j)\)</span> に対応。</td>
</tr>
<tr>
<td align="center"><span class="math">\(Z_{ij}^m\)</span></td>
<td align="left">マルチループのエネルギーを考慮する。</td>
</tr>
<tr>
<td align="center"><span class="math">\(Z_{ij}^{m1}\)</span></td>
<td align="left">2次構造のダブルカウントを防ぐ。マルチループのエネルギーを考慮する。</td>
</tr>
</tbody>
</table>
<h3>再帰式</h3>
<div class="math">$$
\begin{aligned}
Z_{i j}
&amp;=1.0+\sum_{k=i}^{j-1} Z_{i, k} Z_{k+1, j}^{1} \\
Z_{i j}^{1}
&amp;=\sum_{k=i}^{j} Z_{i k}^{b} \\
Z_{i j}^{b}
&amp;=e^{-\left[F_{1}(i, j) / k T\right]}+\sum_{k=i+1}^{j-2} \sum_{l=k+1}^{j-1} Z_{h l}^{b} e^{-\left[F_{2}(i, j, k, l) / k T\right]}+\sum_{k=i+2}^{j-1} Z_{i+1, k-1}^{m} Z_{k, j-1}^{m 1} e^{-[(a+b) / k T]} \\
Z_{i j}^{m}
&amp;=\sum_{k=i}^{j-1}\left(e^{-[c(k-i) / k T]}+Z_{i, k-1}^{m}\right) Z_{k, j}^{m 1} \\
Z_{i j}^{m 1}
&amp;=e^{-[b / k T]} \sum_{k=i+1}^{j} Z_{i k}^{b} e^{-[c(j-k) / k T]}
\end{aligned}
$$</div>
<h3>具体的な解説</h3>
<p>ここから、一つずつそれぞれの役割や、再帰式の意味を詳しく見ていく。</p>
<h4><span class="math">\(Z_{ij}\)</span></h4>
<div class="math">$$Z_{i j}=1.0+\sum_{k=i}^{j-1} Z_{i, k} Z_{k+1, j}^{1}$$</div>
<ul>
<li>第1項: <span class="math">\(i\)</span> から <span class="math">\(j\)</span> までが一つも塩基対を組まないような2構造のボルツマン因子に対応。塩基対が一つもなければエネルギーは <span class="math">\(0\)</span> なので、<span class="math">\(e^0=1\)</span> となる。</li>
<li>第2項: <span class="math">\(i\)</span> から <span class="math">\(k\)</span> までの部分配列の全ての2次構造のボルツマン因子の和に、<span class="math">\(k+1\)</span> がその下流の塩基と塩基対を組んで、そのさらに下流には塩基対が存在しない構造のボルツマン因子を掛け合わせたもの。</li>
</ul>
<h4><span class="math">\(Z_{i j}^{1}\)</span></h4>
<p><span class="math">\(i\)</span> がその下流の塩基と塩基対を組んで、さらにその下流には塩基対が存在しない構造のボルツマン因子の和。</p>
<div class="math">$$Z_{i j}^{1}=\sum_{k=i}^{j} Z_{i k}^{b}$$</div>
<ul>
<li><span class="math">\(i\)</span> が下流と形成する塩基対で閉じられた部分構造のボルツマン因子が <span class="math">\(Z_{ik}^b\)</span> に対応する。その下流の部分のエネルギーは <span class="math">\(0\)</span> なので、<span class="math">\(e^0=1\)</span> がかけられているが、明示的には式に現れない。</li>
</ul>
<h4><span class="math">\(Z_{ij}^b\)</span></h4>
<p><span class="math">\(i\)</span> と <span class="math">\(j\)</span> が塩基対を組む時の全ての可能な2次構造のボルツマン因子の和であり、Zuker Algorithm の <span class="math">\(V(i,j)\)</span> に対応。</p>
<div class="math">$$Z_{i j}^{b}
=e^{-\left[F_{1}(i, j) / k T\right]}+\sum_{k=i+1}^{j-2} \sum_{l=k+1}^{j-1} Z_{h l}^{b} e^{-\left[F_{2}(i, j, k, l) / k T\right]}+\sum_{k=i+2}^{j-1} Z_{i+1, k-1}^{m} Z_{k, j-1}^{m 1} e^{-[(a+b) / k T]}$$</div>
<ul>
<li>第1項: 塩基対 <span class="math">\((i,j)\)</span> がヘアピンループを閉じる時のボルツマン因子</li>
<li>第2項: 塩基対 <span class="math">\((i,j)\)</span> がstacking,bulge loop, internal loopを閉じる時のボルツマン因子</li>
<li>第3項: 塩基対 <span class="math">\((i,j)\)</span> がmulti-loopを閉じる時のボルツマン因子。<span class="math">\(i+1\)</span> から <span class="math">\(k-1\)</span> までの <span class="math">\(Z^m\)</span> と <span class="math">\(k\)</span> から <span class="math">\(j-1\)</span> までの <span class="math">\(Z^{m1}\)</span> を掛け合わせたもの。<span class="math">\(e^{-[(a+b) / k T]}\)</span> は、<span class="math">\((i,j)\)</span> がmulti-loopを閉じる時のエネルギーの寄与分を表す。</li>
</ul>
<h4><span class="math">\(Z_{i j}^{m}\)</span></h4>
<p><span class="math">\(i\)</span> から <span class="math">\(j\)</span> までがmulti-loopの中にあって、かつ塩基対で閉じられた部分構造を1つ以上持つ構造のボルツマン因子の和。</p>
<div class="math">$$
\begin{aligned} Z_{i j}^{m} &amp;=\sum_{k=i}^{j-1}\left(e^{-[c(k-i) / k T]}+Z_{i, k-1}^{m}\right) Z_{k, j}^{m 1} \\ &amp;=\sum_{k=i}^{j-1} e^{-[c(k-i) / k T]} Z_{k, j}^{m 1}+\sum_{k=i}^{j-1} Z_{i, k-1}^{m} Z_{k, j}^{m 1}
\end{aligned}
$$</div>
<ul>
<li>第1項: <span class="math">\(i\)</span> から <span class="math">\(j\)</span> までがmulti-loopの中にあって、かつ塩基対で閉じられた部分構造を1つだけ持つ構造のボルツマン因子の和。</li>
<li>第2項: <span class="math">\(i\)</span> から <span class="math">\(j\)</span> までがmulti-loopの中にあって、かつ塩基対で閉じられた部分構造を2個以上持つ構造のボルツマン因子の和。</li>
</ul>
<h4><span class="math">\(Z_{i j}^{m 1}\)</span></h4>
<p><span class="math">\(i\)</span> から <span class="math">\(j\)</span> までの部分配列がmulti-loopの中にあり、<span class="math">\(i\)</span> が下流の塩基と塩基対を形成し、さらにその下流の塩基が塩基対が存在しない構造のボルツマン因子の和。</p>
<div class="math">$$Z_{i j}^{m 1}=e^{-[b / k T]} \sum_{k=i+1}^{j} Z_{i k}^{b} e^{-[c(j-k) / k T]}
$$</div>
<ul>
<li><span class="math">\(e^{-[b / k T]}\)</span> は、multi-loopの中にあって、multi-loopを閉じる塩基対一つ一つにかかるエネルギーの寄与分を表す。</li>
<li><span class="math">\(Z_{i k}^{b}\)</span> は、<span class="math">\(i\)</span> がその下流の塩基と塩基対を組んだ時に、その塩基対に閉じられた部分構造のボルツマン因子の和。</li>
<li><span class="math">\(e^{-[c(j-k) / k T]}\)</span> は、さらに下流にある部分のエネルギーの和。</li>
</ul>
<p>ここまで、<b>分配関数 <span class="math">\(Z\)</span> の計算</b>の説明を行った。</p>
<h3>塩基対確率の計算</h3>
<p>続いて、<b>塩基対確率の計算方法</b>の説明に移る。</p>
<p>ボルツマン分布の仮定のもとでは、<span class="math">\(i\)</span> 番目と <span class="math">\(j\)</span> 番目の塩基対確率は
</p>
<div class="math">$$P_{i j}=\frac{\sum_{\sigma \in \mathrm{S}(i, j)} e^{-E(\sigma) / k T}}{Z}$$</div>
<p>によって表すことができた。なお、<span class="math">\(\mathrm{S}(i, j)\)</span> は、<span class="math">\(i\)</span> と <span class="math">\(j\)</span> が塩基対を組むような全ての二次構造の集合を示す。</p>
<p>配列の長さが長くなると、この集合 <span class="math">\(\mathrm{S}(i, j)\)</span> のサイズが大きくなり、数え上げることができなくなる。</p>
<p>そこで、数え上げなくても効率的に計算することのできる方法が必要になる。</p>
<p>これを実現するために、<font color="red"><b>配列全体を <span class="math">\((i,j)\)</span> 塩基対を基準にして内側と外側に分けて考える。</b></font>そして、内側のボルツマン因子と外側のボルツマン因子を計算して掛け合わせることで全体のボルツマン因子を計算する。</p>
<h4>内側</h4>
<p>ここで、<span class="math">\((i,j)\)</span> が塩基対を組む時の内側部分のボルツマン因子は、先ほど分配関数を計算する過程で現れた <span class="math">\(Z^b_{i,j}\)</span> そのものになる。</p>
<h4>外側</h4>
<p>一方、外側部分を <span class="math">\(W^b_{i,j}\)</span> とする。これを正確に言うと<b>「<span class="math">\((i,j)\)</span> が塩基対を組む時の、<span class="math">\(i\)</span> から <span class="math">\(j\)</span> までの部分配列を除いた外側配列の、全ての可能な2次構造のボルツマン因子の和」</b>になる。</p>
<p>これは、以下の式によって求めることができる。</p>
<div class="math">$$
\begin{array}{l}
{W_{i, j}^{b}} \\
{=Z_{1, i-1} \cdot Z_{j+1, L}+\sum_{h, l} W_{h, l}^{b} \cdot e^{-F_{2}(i, j, h, l) / k T}} \\
{+e^{b / k T} \sum_{h, l} W_{h, l}^{b} \cdot e^{(a+b) / k T}\left[\begin{array}{c}{Z_{h+1, i-1}^{m} \cdot e^{-(l-j-1) c / k T}} \\ {+Z_{j+1, l-1}^{m} \cdot e^{-(i-h-1) c / k T}} \\ {+Z_{h+1, i-1}^{m} \cdot Z_{j+1, l-1}^{m}}\end{array}\right]}
\end{array}
$$</div>
<ul>
<li>第1項: <span class="math">\((i,j)\)</span> 塩基対の上流と <span class="math">\((i,j)\)</span> 塩基対の下流で塩基対を形成しないような全ての可能な2次構造のボルツマン因子の和。</li>
<li>第2項: <span class="math">\((i,j)\)</span> 塩基対の1つ外側にある <span class="math">\((h,l)\)</span> 塩基対がstackingを閉じる場合のボルツマン因子の和。</li>
<li>第3項: <span class="math">\((i,j)\)</span> 塩基対の1つ外側にある <span class="math">\((h,l)\)</span> 塩基対がmult-loopを閉じる場合のボルツマン因子の和。なお、大括弧の中身は、以下を意味する。<ul>
<li>第1行: 左側だけに部分構造がある場合</li>
<li>第2行: 右側だけに部分構造がある場合</li>
<li>第3行: 両側に部分構造がある場合</li>
</ul>
</li>
</ul>
<h4>結論</h4>
<p>以上により、以下の式で塩基対確率を求めることができる。</p>
<div class="math">$$P_{i j}=\frac{Z_{i j}^{b} \cdot W_{i j}^{b}}{Z}$$</div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        fonts: [['STIX', 'TeX']]," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            <div>
</div>

            
            
            <hr/>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h5>Published</h5>
            <time itemprop="dateCreated" datetime="2019-06-24T00:00:00+09:00"> 6 24, 2019</time>

<h5>Last Updated</h5>
<time datetime="2019-06-24T00:00:00+09:00"> 6 24, 2019</time>

            <h5>Category</h5>
            <a class="category-link" href="https://iwasakishuto.github.io/study/notes/categories.html#genomupei-lie-jie-xi-lun-ii-ref">ゲノム配列解析論Ⅱ</a>
            <h5>Tags</h5>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://iwasakishuto.github.io/study/notes/tags#3s-ref">3S
                    <span>56</span>
</a></li>
                <li><a href="https://iwasakishuto.github.io/study/notes/tags#genomupei-lie-jie-xi-lun-ii-ref">ゲノム配列解析論Ⅱ
                    <span>4</span>
</a></li>
            </ul>
<h5>Contact</h5>
    <a href="https://twitter.com/cabernet_rock" title="My twitter Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-twitter sidebar-social-links"></i></a>
    <a href="https://github.com/iwasakishuto" title="My github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="https://www.facebook.com/iwasakishuto" title="My facebook Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-facebook sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="https://github.com/Pelican-Elegant/elegant/" title="Theme Elegant Home Page">Elegant</a></li>
    </ul>
</div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>
        <script src="https://iwasakishuto.github.io/js/smooth-scroll.polyfills.min.js"></script>

    
        <link rel="stylesheet" type="text/css" href="https://iwasakishuto.github.io/study/notes/theme/css/custom.css" media="screen">
    </body>
    <!-- Theme: Elegant built for Pelican
    License : MIT -->
</html>